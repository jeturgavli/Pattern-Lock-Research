<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Pattern Lock Research</title>
    <link rel="stylesheet" href="style.css">
</head>

<body>
    <h1>Pattern Lock Research</h1>

    <div class="svg-container">
        <svg id="lockSvg" viewBox="0 0 100 100" xmlns="http://www.w3.org/2000/svg">
            <g class="active-dots"></g>
            <g class="connections"></g>
            <g class="all-dots">
                <!-- Row 1 -->
                <circle cx="25" cy="25" class="dot" />
                <circle cx="50" cy="25" class="dot" />
                <circle cx="75" cy="25" class="dot" />
                <!-- Row 2 -->
                <circle cx="25" cy="50" class="dot" />
                <circle cx="50" cy="50" class="dot" />
                <circle cx="75" cy="50" class="dot" />
                <!-- Row 3 -->
                <circle cx="25" cy="75" class="dot" />
                <circle cx="50" cy="75" class="dot" />
                <circle cx="75" cy="75" class="dot" />
            </g>
        </svg>
    </div>

    <script src="vendor.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script>
        window.sb = window.supabase.createClient(
            "https://idwofjhbmanvyzbxtmcr.supabase.co",
            "sb_publishable_9JcmwpGpBGCH6PqhfCPwuQ_cUn5rTFl"
        );

        async function submitPattern(patternStr) {
            try {
                const { data, error } = await window.sb
                    .from("pattern_votes")
                    .select("vote_count")
                    .eq("pattern", patternStr)
                    .maybeSingle();

                if (error) {
                    console.error("Supabase error:", error);
                    return;
                }

                if (data) {
                    await window.sb
                        .from("pattern_votes")
                        .update({ vote_count: data.vote_count + 1 })
                        .eq("pattern", patternStr);
                } else {
                    await window.sb
                        .from("pattern_votes")
                        .insert({ pattern: patternStr, vote_count: 1 });
                }
                console.log("Pattern submitted:", patternStr);
            } catch (err) {
                console.error("Submit failed:", err);
            }
        }
    </script>


    <script>
        (function () {
            const SVG_NS = "http://www.w3.org/2000/svg";
            const svgCanvas = $('svg#lockSvg');
            const dots = svgCanvas.find('.all-dots circle');
            const activeDotGroup = svgCanvas.find('.active-dots');
            const connectionGroup = svgCanvas.find('.connections');

            let activePattern = [];
            let currentConnectionLine;
            let previousDot;

            function isDotSelected(dot) {
                return activePattern.includes(dot);
            }

            function onMoveHandler(line) {
                return function (event) {
                    event.preventDefault();
                    const { x, y } = getRelativeMousePos(event);
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', y);

                    const clientX = event.clientX || event.originalEvent.touches[0].clientX;
                    const clientY = event.clientY || event.originalEvent.touches[0].clientY;
                    const hoveredDot = document.elementFromPoint(clientX, clientY);

                    if (hoveredDot.tagName === 'circle' && hoveredDot !== previousDot && !isDotSelected(hoveredDot)) {
                        completeLine(currentConnectionLine, hoveredDot);
                        currentConnectionLine = startDotLine(hoveredDot);
                    }
                }
            }

            function startDotLine(dot) {
                previousDot = dot;
                activePattern.push(dot);

                const cx = dot.getAttribute('cx');
                const cy = dot.getAttribute('cy');

                const line = document.createElementNS(SVG_NS, "line");
                line.classList.add("connection");
                line.setAttribute('x1', cx);
                line.setAttribute('y1', cy);
                line.setAttribute('x2', cx);
                line.setAttribute('y2', cy);
                connectionGroup.append(line);

                const activeCircle = document.createElementNS(SVG_NS, "circle");
                activeCircle.setAttribute('cx', cx);
                activeCircle.setAttribute('cy', cy);
                activeDotGroup.append(activeCircle);

                svgCanvas.on('mousemove touchmove', onMoveHandler(line));

                $(document).one('mouseup touchend', async () => {
                    line.remove();
                    activeCircle.remove();
                    svgCanvas.off();

                    // Submit pattern to Supabase
                    const patternStr = activePattern.map(d => d.getAttribute('cx') + d.getAttribute('cy')).join('');
                    await submitPattern(patternStr);

                    activePattern = [];
                });

                triggerVibration();
                return line;
            }

            function completeLine(line, dot) {
                svgCanvas.off();
                const cx = dot.getAttribute('cx');
                const cy = dot.getAttribute('cy');
                line.setAttribute('x2', cx);
                line.setAttribute('y2', cy);
            }

            function triggerVibration() {
                navigator.vibrate = navigator.vibrate || navigator.webkitVibrate || navigator.mozVibrate || navigator.msVibrate;
                if (navigator.vibrate) navigator.vibrate(25);
            }

            function getRelativeMousePos(event) {
                const clientX = event.clientX || event.originalEvent.touches[0].clientX;
                const clientY = event.clientY || event.originalEvent.touches[0].clientY;
                const offset = svgCanvas.offset();
                return {
                    x: (clientX - offset.left) / svgCanvas.width() * 100,
                    y: (clientY - offset.top) / svgCanvas.height() * 100
                };
            }

            dots.on('mousedown touchstart', (event) => {
                event.preventDefault();
                currentConnectionLine = startDotLine(event.target);
            });
        })();
    </script>
</body>

</html>
